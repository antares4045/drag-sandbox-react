import React, { Component } from 'react'

import Vector from 'vector.js'
import Node from 'components/sandbox/Node.js'
import NodeLink from './NodeLink'
import Circle from './Circle.js'

import throttle from 'lodash/throttle'

import {DEBUG, directionShift} from 'config.js'


class DragSandbox extends Component {

    constructor(props) {
        super(props)
        
        this.contentRef = React.createRef()
        this.workAreaRef = React.createRef()
        

        this.focusedObject = null
        this.links = []
        this.nodes = [
            { pos : {x: 10, y : 15},
              key : 'a'                
            },
            { pos : {x: 1001, y : 150},
              key : 'b'              
            },
            { pos : {x: -10, y : 100},
              key : 'c'          
            }
        ].map(elem => {

            let ports = [[0, 0], [1, 0] , [0, 1]].map( ([x , y], index) => {
                const pos = {y : 15 + 20 * y, x : 50 * x}


                const direction = new Vector(directionShift).rot(Math.PI * x).add(pos)

                return {pos, direction, key: index,  fill : `#${x ? 'ff' : '00'}${y ? 'ff' : '00'}ff`}
            })


            return {...elem, ports}
        })


        this.state = {
            anchor: Vector.new(100, 100),
            shift: Vector.new(15, 356.2368307045553),
            mul: 0.9092407796451915,
            anchored: false,
            linkAnchor : Vector.new(0,0)
        }
    }
    componentDidMount(){
        document.addEventListener("keydown", (e) => this.onKeyDown(e));
    }
    componentWillUnmount(){
        document.removeEventListener("keydown", (e) => this.onKeyDown(e));
    }



    onMouseUp(e) {//release
        if(this.state.anchored || this.state.tryLink)
            this.setState({anchored: false, tryLink : null })
        this.focusedObject = null
    }
    onMouseDown({ nativeEvent }) {//press

        this.setState({'anchor': this.posToCoord(nativeEvent), anchored: true })
    }

    onWheel(event) {//wheel
        event.stopPropagation();
        const { nativeEvent } = event
        const mul = this.state.mul * Math.pow(2, nativeEvent.wheelDelta / 1000) || this.state.mul
        //nativeEvent = {pageX:0, pageY:0}
        const anchor = this.posToCoord(nativeEvent)
        this.setState({'shift': anchor.sum(this.state.shift).mult(this.state.mul).divided(mul).sub(anchor), anchor, mul })
    }

    posToCoord(nativeEvent) {

        const pos = Vector.fromNativeEvent(nativeEvent)

        return pos.divided(this.state.mul).sub(this.state.shift)
    }
    coordToPos(coord) {
        return coord.sum(this.state.shift).mil(this.state.mul)
    }

    linkPortToPoints({node, port}){
        const nodeProps = this.nodes.find(n => n.key == node)

        const portProps = nodeProps.ports.find(p => p.key == port)

        const nodePos = new Vector(nodeProps.pos)

        return {port: nodePos.sum(portProps.pos), direction: nodePos.sum(portProps.direction)}
    }

    onMouseMove(event) {
        const { nativeEvent } = event
        
        if (this.state.anchored) {
            
            this.setState({'shift': Vector.fromNativeEvent(nativeEvent).divided(this.state.mul).sub(this.state.anchor) })
        }else if(this.focusedObject){
            this.focusedObject.onMouseMove(event)
        }else if(this.state.tryLink){

            this.setState({'linkAnchor' : this.posToCoord(nativeEvent)})
        }

    }


    onKeyDown(event){
        switch(event.code){
            case "KeyR" : return this.resize() 
        }
        

    }
    resize(){
        if(!this.contentRef.current || !this.workAreaRef.current){

            return
        }
            
        const contentBox = this.contentRef.current.getBBox()
        const containerBox = this.workAreaRef.current.getBBox()

        const xMul =  containerBox.width / contentBox.width
        const yMul =  containerBox.height / contentBox.height

        let shift = Vector.new(-contentBox.x, -contentBox.y)

        if(xMul < yMul){

            shift.y += (containerBox.height / xMul - contentBox.height) / 2 

            this.setState({mul : xMul, shift})
        }else{

            shift.x += (containerBox.width / yMul - contentBox.width) / 2 

            this.setState({mul : yMul, shift})
        }
    
    }
    RenderNode(node, index){

        const updPosLambda = (pos) => {
            node.pos = pos
            this.forceUpdate()

        }

        return (
            <Node {...node} 
            posToCoord={(arg) => this.posToCoord(arg)} 
            updPos={updPosLambda} key={index} 
            startCursorMoveHandlering={(obj) => this.focusedObject = obj}
            tryStartConnection={(args) => this.tryStartConnection({...args, node: node.key})}
            tryEndConnection={(args) => this.tryEndConnection({...args, node: node.key})}
            ></Node>
        )
    }
    RenderLink(fromPort, toPort, extra={}, index=null){

        const fromCoords = this.linkPortToPoints(fromPort)
        const toCoords = toPort == null ? {port : this.state.linkAnchor, direction : this.state.linkAnchor} : this.linkPortToPoints(toPort)
      
        //console.log(fromCoords, toCoords)

        if(fromCoords.port.isEq(toCoords.port) && fromCoords.direction.isEq(toCoords.direction))
        {
            fromCoords.direction.add({x:0, y: 50})

            toCoords.direction.add({x:0, y: -50})
        }

        return (<NodeLink {...extra} key={index} fromCoords={fromCoords} toCoords={toCoords}/>)
    }
    tryStartConnection({port, node}){
        console.log(port, node)
        this.setState({tryLink : {node, port}, linkAnchor: this.linkPortToPoints({node, port}).port})
    }
    tryEndConnection({port, node}){
        console.log(this.state.tryLink, '->', {port, node})

        this.links.push(
            {from : this.state.tryLink, to: {port, node}}
        )

        this.setState({tryLink : null})

    }
    render() {

        const { anchor, shift, mul } = this.state

        console.log('RENDER')
        return (
            <div style={{width : "100%", height : "100%", display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', backgroundColor: '#f0f0f0'}}>
            <div>
                {DEBUG && JSON.stringify(this.nodes)}
                {DEBUG && JSON.stringify(this.links)}
                <button onClick={() => this.resize()}>
                    Resize
                </button>
            </div>
            <svg
                width='90%'
                height='90%'
                onClick={(e) => this.onMouseUp(e)}
                onMouseDown={(e) => this.onMouseDown(e)}
                onWheel={(e) => this.onWheel(e)}
                onMouseMove={throttle((e) => this.onMouseMove(e), 100)}
                onKeyPress={(e) => this.onKeyDown(e)}
            >

                <rect fill='none' width="100%" height="100%"   stroke='black' ref={this.workAreaRef}></rect>
                <g style={{ transform: `scale(${mul}) translate(${shift.x}px, ${shift.y}px)`}}>
                    {DEBUG ? <Circle pos={anchor} fill={'yellow'} r={'5'}></Circle> : null}
                    {DEBUG ? <Circle pos={this.state.linkAnchor} fill={'red'} r={'5'}></Circle> : null}
    
                    <g style={!DEBUG ? {} : { 'outline': '1px solid green' }} ref={this.contentRef}>
                        {this.links.map((lnk, index) => this.RenderLink(lnk.from, lnk.to, lnk, index))}
                        {this.state.tryLink ? this.RenderLink(this.state.tryLink, null): null}

                        {this.nodes.map((node, index) => this.RenderNode(node, index))}
                    </g>
                </g>
            </svg>
            </div>
        )
    }
}
//<Circle pos={shift} fill={'green'} r={'5'}></Circle>


export default DragSandbox